// const fs = require('fs');
const Tour = require('./../models/tourModel');
const APIfeatures = require('./../utils/apiFeatures');
const catchAsync = require('./../utils/catchAsync');
const AppError = require('./../utils/appError');
const factory = require('./handlerFactory');

// Reading data from tours.json file
// const tours = JSON.parse(fs.readFileSync(`${__dirname}/../dev-data/data/tours-simple.json`));

// PARAM MIDDLEWARE TO CHECK IF ID IS PRESENT
const checkId = (req, res, next) =>{  
    const id = req.params.id;
   if(id){
       next();
}
}

// ALIAS MIDDLEWARE FOR TOP AND CHEAPEST TOUR
const aliasTopTours = (req, res, next) => {
    req.query.limit = '5';
    req.query.sort = 'price';
    req.query.fields = 'name, price, ratingAverage, summary, difficulty';
    next();
  };

// MIDDLEWARE TO CHECK IF NAME AND PRICE IS PRESENT IN A TOUR SUBMITION
// const checkBody = (req, res, next) =>{
//     if(!req.body.name || !req.body.price){
//         return res.status(400).json({
//             status: 'Request Failed',
//             message: 'Name or Price is missing'
//         })
//     }
//     next();
// }

// TOURS ROUTE HANDLER
const createTour = factory.createOne(Tour);
// The code below is the same as the one above, but using factory function
//Try and catch was used to handle errors in async functions, but now replaced by catchAsync utility function
// CREATE TOUR

// const createTour = catchAsync(async (req, res, next) => {
//     const newTour = await Tour.create(req.body);
//  res.status(201).json({
//         status: 'success',
//         data:{
//             Tour: newTour
//         }
//     });
//     });


// GET ALL TOURS
const getAllTour = factory.getAll(Tour);
// const getAllTour = catchAsync(async(req, res, next) => {
//     // try{
//         // QUERY BUILDING
//         // (1A) FILTERING
//         // req.query gets the query strings
//         // const queryObjects = {...req.query};
//         // const excludedFields = ['page', 'sort', 'limit', 'fields' ];
//         // excludedFields.forEach(el=>delete queryObjects[el]);

//         // // (1B) ADVANCE FILETERING
//         // let queryStr = JSON.stringify(queryObjects)
//         // queryStr = queryStr.replace(/\b(gt|gte|lt|lte)\b/g, match => `$${match}`);
//         //     console.log(JSON.parse(queryStr));
//         // let query = Tour.find(JSON.parse(queryStr));

//         // // (2) SORTING
//         // if(req.query.sort){
//         //     // mongoose accepts sort parameters with space, but comma(,) is used in the URL, therefore there is to separate the parameters by comma and join again by space, which is acceptable by mongoose.
//         //     const sortBy = req.query.sort.split(',').join(' ');
//         //         query = query.sort(sortBy);
//         // }else{
            
//         // }

//         // // (3) FIELD LIMITING
//         // if(req.query.fields){
//         //     const fields = req.query.fields.split(',').join(' ');
//         //     query = query.select(fields);
//         //     // The line of code two steps above will produce similar as below, mongoose accepts fields parameters with space, note that.
//         //     // query = query.select('name duration price');
//         // }else{
//         //     // the "-__v will hide the automatically generated __v field generated by mongo DB"
//         //     query = query.select('-__v');
//         // }

//         // // (4) PAGINATION
//         // // page and limit are multiplied by 1 to convert the query string value to number
//         // const page  = req.query.page * 1 || 1;
//         // const limit = req.query.limit * 1 || 10;
//         // const skip = (page - 1) * limit;
//         //  query = query.skip(skip).limit(limit);
//         // //  TO CHECK IF THE TOTAL NUMBER OF REQUEST IS HIGHER THAN THE DATASET
//         // if(req.query.page){
//         //     const numTours = await Tour.countDocuments();
//         //     if(skip >= numTours || page < 1){
//         //         res.status(400).json({
//         //             status:'not available',
//         //             message:'Page not available'

//         //         })
//         //     }; 
//         // }
       
//         const features = new APIfeatures(Tour.find(), req.query).filter().sort().limitFields().paginate();
//         const tours = await features.query;
//         // const tours = await Tour.find({
//         //     duration:{$lte:5},
//         //     difficulty: 'easy'
//         // });
// // The filter code below works same as above
//         // const tours = await Tour.find().where('duration').lte(5).where('difficulty').equals('easy');

//     res.status(200).json({
//         status: 'success',
//         result : tours.length,
//         data:{
//             tours
//         }
//     });
//     // }catch(err){
//     //   res.status(400).json({
//     //     status: 'Failed', 
//     //     message: err
//     //   })
//     // };
// });

// GET A TOUR
const getTourById = factory.getOne(Tour, {path: 'reviews'});
//     const getTourById = catchAsync(async (req, res, next) =>{ 
//     // both lines of code below work the same, but if you want to find other param apart from _id, then use findOne
//     const tour = await Tour.findById(req.params.id).populate('reviews');
//    // console.log(req.params.id);
//     // const tour = await Tour.findOne({id: req.params.id});
//     if (!tour) {
//     return next(new AppError('No tour found with that ID', 404));
//     }
//     res.status(200).json({
//         status: 'success',
//         data: { tour }
//     });
// });

// UPDATE TOUR BY ID

const updateTour = factory.updateOne(Tour);

    //  const updateTour = catchAsync(async (req, res, next) => {
    //     const tour = await Tour.findByIdAndUpdate(req.params.id, req.body, {
    //         new:true,
    //         runValidators:true
    //     });
    //     if (!tour) {
    //         return next(new AppError(`No tour found with that ID`, 404));   
    //     }
    //         res.status(200).json({
    //             status: 'success',
    //      data: {
    //          tour
    //         }
    //     }) 
    //  })

// DELETE TOUR BY ID

const deleteTour = factory.deleteOne(Tour);
// The code below is the same as the one above, but using factory function

// const deleteTour = catchAsync(async (req, res, next) => {
//         const deletedTour = await Tour.findByIdAndDelete(req.params.id);
//         if (!deletedTour) {
//             res.status(404).json({
//                 status: 'failed',
//                 message: 'Tour not found'
//             });
//             return;
//         }
//         res.status(200).json({
//             status: 'success',
//             message: `Tour title "${deletedTour.name}" was deleted successfully`
//         });
// });

// AGGREGATION PIPELINE - Matching and Grouping
const getTourStats = catchAsync(async (req, res, next)=> {
const stats = await Tour.aggregate([
    {
        $match: {ratingsAverage:{$gte:4.5}}
    },
    {
    $group: {
        _id:{$toUpper:'$difficulty'},
        numTours:{$sum: 1},
        numRatings: {$sum: '$ratingsQuantity'},
        avgRating: {$avg:'$ratingsAverage'},
        avgPrice: {$avg : '$price'},
        minPrice: {$min : '$price'},
        maxPrice: {$max : '$price'}
        }
    },
    {
        $sort:{avgPrice: -1}
    }
    ]);
    res.status(200).json({
        status:'Succes',
        Total: stats.length,
        Message: stats
    })
    });

    // AGGREGATION PIPELINE - Unwinding and Projecting
    // $Unwind will deconstruct an array of object
    // Projecting will hide a document field
    const getMonthlyPlan = catchAsync(async (req, res, next)=>{
            const year = req.params.year * 1;
           const plan = await Tour.aggregate([
            {
                $unwind:'$startDates'
            },

            {
                $match:{
                    startDates:{
                     $gte: new Date(`${year}-1-1`),
                     $lte: new Date(`${year}-12-31`)
                    }
                }
            },

            {
                $group:{
                    _id:{$month:'$startDates'},
                    numTourStats: {$sum: 1},
                    Tours:{$push:'$name'}
                }
            },

            {
                $addFields:{month: '$_id'}
            },

            {
                $project:{
                    _id:0
                }
            },
            
            {
                $sort:{numTourStats: -1}
            }
           ]);
           res.status(200).json({
            status:'OK',
            Total:plan.length,
            Message: plan
           })
        
    });

    // GET TOURS WITHIN A DISTANCE
    // This will find tours within a certain distance from a given latitude and longitude
    ///tours-within/:distance/center/:latlng/unit/:unit'
    const getToursWithin = catchAsync(async (req, res, next) => {
        const { distance, latlng, unit } = req.params;
        const [lat, lng] = latlng.split(',');
        const radius = unit === 'mi' ? distance / 3963.2 : distance / 6378.1; // Radius in radians

        if (!lat || !lng) {
            return next(new AppError('Please provide latitude and longitude in the format lat,lng.', 400));
        }
//$geoWithin and $centerSphere are both geospatial operators used to query documents based on their location.
        const tours = await Tour.find({
            startLocation: { $geoWithin: { $centerSphere: [[lng, lat], radius] } }
        });

        res.status(200).json({
            status: 'success',
            result: tours.length,
            data: { tours }
        });
    });

    // GET DISTANCE TO ALL AVAILABLE TOURS FROM A PARTICULAR LOCATION
    // This will calculate the distance from a given latitude and longitude to all available tours
const getDistanceTours = catchAsync(async (req, res, next) => {
    const { latlng, unit } = req.params;
    const [lat, lng] = latlng.split(',');
    const multiplier = unit === 'mi' ? 0.000621371 : 0.001; // Convert to miles or kilometers
    if (!lat || !lng) {
        return next(new AppError('Please provide latitude and longitude in the format lat,lng.', 400));
    }
    const distances = await Tour.aggregate([
        {
            $geoNear: {
                near: { type: 'Point', coordinates: [lng * 1, lat * 1] },
                distanceField: 'distance',
                spherical: true,
                distanceMultiplier: multiplier,
               
            }
        },
        {
            $project: {
                name: 1,
                distance: 1
            }
        }
    ]);
    res.status(200).json({
        status: 'success',
        result: distances.length,
        data: { distances }
    });
});

     module.exports = {aliasTopTours, getAllTour, createTour, getTourById, updateTour, deleteTour, checkId, getTourStats, getMonthlyPlan, getToursWithin, getDistanceTours};