// const fs = require('fs');
const Tour = require('./../models/tourModel');
const APIfeatures = require('./../utils/apiFeatures');
const catchAsync = require('./../utils/catchAsync');
const AppError = require('./../utils/appError');

// Reading data from tours.json file
// const tours = JSON.parse(fs.readFileSync(`${__dirname}/../dev-data/data/tours-simple.json`));

// PARAM MIDDLEWARE TO CHECK IF ID IS PRESENT
const checkId = (req, res, next) =>{  
    const id = req.params.id;
   if(id){
       next();
}
}

// ALIAS MIDDLEWARE FOR TOP AND CHEAPEST TOUR
const aliasTopTours = (req, res, next) => {
    req.query.limit = '5';
    req.query.sort = 'price';
    req.query.fields = 'name, price, ratingAverage, summary, difficulty';
    next();
  };

// MIDDLEWARE TO CHECK IF NAME AND PRICE IS PRESENT IN A TOUR SUBMITION
// const checkBody = (req, res, next) =>{
//     if(!req.body.name || !req.body.price){
//         return res.status(400).json({
//             status: 'Request Failed',
//             message: 'Name or Price is missing'
//         })
//     }
//     next();
// }

// TOURS ROUTE HANDLER

//Try and catch was used to handle errors in async functions, but now replaced by catchAsync utility function
// CREATE TOUR

const createTour = catchAsync(async (req, res, next) => {
    const newTour = await Tour.create(req.body);
 res.status(201).json({
        status: 'success',
        data:{
            Tour: newTour
        }
    });
    });


// GET ALL TOURS
const getAllTour = catchAsync(async(req, res, next) => {
    // try{
        // QUERY BUILDING
        // (1A) FILTERING
        // req.query gets the query strings
        // const queryObjects = {...req.query};
        // const excludedFields = ['page', 'sort', 'limit', 'fields' ];
        // excludedFields.forEach(el=>delete queryObjects[el]);

        // // (1B) ADVANCE FILETERING
        // let queryStr = JSON.stringify(queryObjects)
        // queryStr = queryStr.replace(/\b(gt|gte|lt|lte)\b/g, match => `$${match}`);
        //     console.log(JSON.parse(queryStr));
        // let query = Tour.find(JSON.parse(queryStr));

        // // (2) SORTING
        // if(req.query.sort){
        //     // mongoose accepts sort parameters with space, but comma(,) is used in the URL, therefore there is to separate the parameters by comma and join again by space, which is acceptable by mongoose.
        //     const sortBy = req.query.sort.split(',').join(' ');
        //         query = query.sort(sortBy);
        // }else{
            
        // }

        // // (3) FIELD LIMITING
        // if(req.query.fields){
        //     const fields = req.query.fields.split(',').join(' ');
        //     query = query.select(fields);
        //     // The line of code two steps above will produce similar as below, mongoose accepts fields parameters with space, note that.
        //     // query = query.select('name duration price');
        // }else{
        //     // the "-__v will hide the automatically generated __v field generated by mongo DB"
        //     query = query.select('-__v');
        // }

        // // (4) PAGINATION
        // // page and limit are multiplied by 1 to convert the query string value to number
        // const page  = req.query.page * 1 || 1;
        // const limit = req.query.limit * 1 || 10;
        // const skip = (page - 1) * limit;
        //  query = query.skip(skip).limit(limit);
        // //  TO CHECK IF THE TOTAL NUMBER OF REQUEST IS HIGHER THAN THE DATASET
        // if(req.query.page){
        //     const numTours = await Tour.countDocuments();
        //     if(skip >= numTours || page < 1){
        //         res.status(400).json({
        //             status:'not available',
        //             message:'Page not available'

        //         })
        //     }; 
        // }
       
        const features = new APIfeatures(Tour.find(), req.query).filter().sort().limitFields().paginate();
        const tours = await features.query;
        // const tours = await Tour.find({
        //     duration:{$lte:5},
        //     difficulty: 'easy'
        // });
// The filter code below works same as above
        // const tours = await Tour.find().where('duration').lte(5).where('difficulty').equals('easy');

    res.status(200).json({
        status: 'success',
        result : tours.length,
        data:{
            tours
        }
    });
    // }catch(err){
    //   res.status(400).json({
    //     status: 'Failed', 
    //     message: err
    //   })
    // };
});

// GET A TOUR
    const getTourById = catchAsync(async (req, res, next) =>{ 
    // both lines of code below work the same, but if you want to find other param apart from _id, then use findOne
    const tour = await Tour.findById(req.params.id);
   // console.log(req.params.id);
    // const tour = await Tour.findOne({id: req.params.id});
    if (!tour) {
    return next(new AppError('No tour found with that ID', 404));
    }
    res.status(200).json({
        status: 'success',
        data: { tour }
    });
});

// UPDATE TOUR BY ID
     const updateTour = catchAsync(async (req, res, next) => {
        const tour = await Tour.findByIdAndUpdate(req.params.id, req.body, {
            new:true,
            runValidators:true
        });
        if (!tour) {
            return next(new AppError(`No tour found with that ID`, 404));   
        }
            res.status(200).json({
                status: 'success',
         data: {
             tour
            }
        }) 
     })

// DELETE TOUR BY ID
const deleteTour = catchAsync(async (req, res, next) => {
        const deletedTour = await Tour.findByIdAndDelete(req.params.id);
        if (!deletedTour) {
            res.status(404).json({
                status: 'failed',
                message: 'Tour not found'
            });
            return;
        }
        res.status(200).json({
            status: 'success',
            message: `Tour title "${deletedTour.name}" was deleted successfully`
        });
});

// AGGREGATION PIPELINE - Matching and Grouping
const getTourStats = catchAsync(async (req, res, next)=> {
const stats = await Tour.aggregate([
    {
        $match: {ratingsAverage:{$gte:4.5}}
    },
    {
    $group: {
        _id:{$toUpper:'$difficulty'},
        numTours:{$sum: 1},
        numRatings: {$sum: '$ratingsQuantity'},
        avgRating: {$avg:'$ratingsAverage'},
        avgPrice: {$avg : '$price'},
        minPrice: {$min : '$price'},
        maxPrice: {$max : '$price'}
        }
    },
    {
        $sort:{avgPrice: -1}
    }
    ]);
    res.status(200).json({
        status:'Succes',
        Total: stats.length,
        Message: stats
    })
    });

    // AGGREGATION PIPELINE - Unwinding and Projecting
    // $Unwind will deconstruct an array of object
    // Projecting will hide a document field
    const getMonthlyPlan = catchAsync(async (req, res, next)=>{
            const year = req.params.year * 1;
           const plan = await Tour.aggregate([
            {
                $unwind:'$startDates'
            },

            {
                $match:{
                    startDates:{
                     $gte: new Date(`${year}-1-1`),
                     $lte: new Date(`${year}-12-31`)
                    }
                }
            },

            {
                $group:{
                    _id:{$month:'$startDates'},
                    numTourStats: {$sum: 1},
                    Tours:{$push:'$name'}
                }
            },

            {
                $addFields:{month: '$_id'}
            },

            {
                $project:{
                    _id:0
                }
            },
            
            {
                $sort:{numTourStats: -1}
            }
           ]);
           res.status(200).json({
            status:'OK',
            Total:plan.length,
            Message: plan
           })
        
    });

     module.exports = {aliasTopTours, getAllTour, createTour, getTourById, updateTour, deleteTour, checkId, getTourStats, getMonthlyPlan};